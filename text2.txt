FX risk refers to the risk associated with fluctuations in foreign exchange rates. 
In the context of SA-CVA, FX risk factors are used to determine the potential credit exposure of a derivative transaction due to changes in exchange rates.


import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import java.util.List;
import java.util.ArrayList;
import java.util.Objects;
import java.util.concurrent.atomic.DoubleAdder;
import java.util.stream.IntStream;

public class DirectSparkRiskEngine {

    // REPLACEMENT: Use a static class instead of 'record' for Java 8/11 compatibility.
    // We use 'public final' fields to allow direct access (e.g., deal.RFTenor) similar to struct.
    public static class Deal {
        public final String RiskWeightDerivingCoperID;
        public final String UltimateParentIdentifier;
        public final String RFTenor;
        public final String CreditQuality;
        public final boolean IsQualifiedIndex;
        public final double RiskWeightedNetSensitivity;

        public Deal(
            String RiskWeightDerivingCoperID,
            String UltimateParentIdentifier,
            String RFTenor,
            String CreditQuality,
            boolean IsQualifiedIndex,
            double RiskWeightedNetSensitivity
        ) {
            this.RiskWeightDerivingCoperID = RiskWeightDerivingCoperID;
            this.UltimateParentIdentifier = UltimateParentIdentifier;
            this.RFTenor = RFTenor;
            this.CreditQuality = CreditQuality;
            this.IsQualifiedIndex = IsQualifiedIndex;
            this.RiskWeightedNetSensitivity = RiskWeightedNetSensitivity;
        }
    }

    /**
     * Public Interface
     */
    public double run(Dataset<Row> inputDataset) {
        // Step 1: Collect data
        List<Row> rows = inputDataset.collectAsList();
        
        // Step 2: Convert to Java Objects (Deal Class)
        List<Deal> records = new ArrayList<>(rows.size());
        for (Row r : rows) {
            records.add(new Deal(
                r.getAs("RiskWeightDerivingCoperID"),
                r.getAs("UltimateParentIdentifier"),
                r.getAs("RFTenor"),
                r.getAs("CreditQuality"),
                // Handle Boolean parsing safety
                r.get(r.fieldIndex("IsQualifiedIndex")) instanceof Boolean ? 
                    r.getAs("IsQualifiedIndex") : Boolean.parseBoolean(r.getAs("IsQualifiedIndex").toString()),
                // Handle Number parsing safety (Double/BigDecimal)
                ((Number) r.getAs("RiskWeightedNetSensitivity")).doubleValue() 
            ));
        }

        // Step 3: Calculate
        return calculateCore(records);
    }

    /**
     * Core Calculation Logic
     */
    private double calculateCore(List<Deal> recordList) {
        // Convert List to Array for performance
        Deal[] nodes = recordList.toArray(new Deal[0]);
        int N = nodes.length;

        DoubleAdder totalVariance = new DoubleAdder();

        // Parallel Calculation
        IntStream.range(0, N).parallel().forEach(i -> {
            Deal r1 = nodes[i];
            double localSum = 0.0;

            // Symmetric Matrix Optimization (j > i)
            for (int j = i + 1; j < N; j++) {
                Deal r2 = nodes[j];

                double rho = getCorrelation(r1, r2);

                // Covariance * 2 (Symmetric)
                localSum += (r1.RiskWeightedNetSensitivity * r2.RiskWeightedNetSensitivity * rho) * 2.0;
            }

            if (localSum != 0.0) {
                totalVariance.add(localSum);
            }
        });

        return Math.sqrt(totalVariance.sum());
    }

    /**
     * Business Rules (Correlation Logic)
     */
    private double getCorrelation(Deal t1, Deal t2) {
        
        // Rule 1: Identical Check
        if (Objects.equals(t1.RiskWeightDerivingCoperID, t2.RiskWeightDerivingCoperID) &&
            Objects.equals(t1.RFTenor, t2.RFTenor) &&
            Objects.equals(t1.CreditQuality, t2.CreditQuality) &&
            Objects.equals(t1.UltimateParentIdentifier, t2.UltimateParentIdentifier)) {
            return 0.0;
        }

        double rho = 1.0;

        // Rule 2: Tenor
        if (!Objects.equals(t1.RFTenor, t2.RFTenor)) {
            rho *= 0.9;
        }

        // Rule 3: Credit Quality
        if (!Objects.equals(t1.CreditQuality, t2.CreditQuality)) {
            rho *= 0.8;
        }

        // Rule 4: Issuer / Parent
        if (Objects.equals(t1.RiskWeightDerivingCoperID, t2.RiskWeightDerivingCoperID)) {
            // Same Issuer -> 1.0
        } 
        else if (Objects.equals(t1.UltimateParentIdentifier, t2.UltimateParentIdentifier) 
                 && t1.UltimateParentIdentifier != null) {
            // Same Parent -> 0.9
            rho *= 0.9;
        } 
        else {
            // Different -> 0.5
            rho *= 0.5;
        }

        return rho;
    }
}
