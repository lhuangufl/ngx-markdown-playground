The Hypothetical Portfolio Exercise (HPE) is a component of the Fundamental Review of the Trading Book (FRTB). 
It involves the hypothetical revaluation of a bank's trading book to assess the impact of market risk factors on the value of the portfolio. The results of the HPE are used to determine the market risk capital charge (MRCC) that the bank must hold to cover potential losses in the trading book.


import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.SparkSession;
import org.apache.spark.sql.types.DataTypes;
import org.apache.spark.sql.types.StructField;
import org.apache.spark.sql.types.StructType;
import java.util.Map;

public class SparkDataProcessor {

    /**
     * Processes the given datasets.
     *
     * @param sparkSession The Spark session to use.
     * @param dsMap A map of dataset names to datasets.
     * @return A processed dataset.
     */
    public Dataset<Row> process(SparkSession sparkSession, Map<String, Dataset<Row>> dsMap) {
        Dataset<Row> inputDataset = dsMap.get("inputDatasetName");
        if (inputDataset != null) {
            // Creating a new column 'mysensitivity' which is 'sensitivity' + 1
            return inputDataset.withColumn(
                "mysensitivity",
                functions.col("sensitivity").plus(1)
            );
        } else {
            // Create a DataFrame schema with a 'mysensitivity' column
            StructType schema = new StructType(new StructField[]{
                DataTypes.createStructField("mysensitivity", DataTypes.DoubleType, true)
            });

            // Create an empty DataFrame with the defined schema
            return sparkSession.createDataFrame(sparkSession.emptyRDD(), schema);
        }
    }
}


import org.apache.commons.math3.optim.linear.LinearObjectiveFunction;
import org.apache.commons.math3.optim.linear.LinearConstraint;
import org.apache.commons.math3.optim.linear.Relationship;
import org.apache.commons.math3.optim.linear.SimplexSolver;
import org.apache.commons.math3.optim.linear.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.linear.NonNegativeConstraint;

public class HedgeAllocationSolver {

    public static void main(String[] args) {
        // Define the hedge sensitivity array and ideal allocation ratio
        double[] hedgeSensitivityArray = {10, 20};

        // Calculate the total aggregate hedge sensitivity by summing the elements of the array
        double totalAggregateHedgesSensitivity = 0;
        for (double sensitivity : hedgeSensitivityArray) {
            totalAggregateHedgesSensitivity += sensitivity;
        }
        double idealHedgeAllocationRatioForSA = 0.75; // This would be ratioConstant

        // The objective function coefficients (in the Python code, this is hedgeSensitivityArray - idealHedgeAllocationRatioForSA * totalAggregateHedgesSensitivity)
        double[] objectiveCoefficients = new double[hedgeSensitivityArray.length];
        for (int i = 0; i < hedgeSensitivityArray.length; i++) {
            objectiveCoefficients[i] = hedgeSensitivityArray[i] - idealHedgeAllocationRatioForSA * totalAggregateHedgesSensitivity;
        }

        // Create the linear objective function to minimize
        LinearObjectiveFunction objectiveFunction = new LinearObjectiveFunction(objectiveCoefficients, 0);

        // Define the constraints (in this case, we are not enforcing boolean constraints)
        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();
        for (int i = 0; i < hedgeSensitivityArray.length; i++) {
            // Each hedge sensitivity must be non-negative
            constraints.add(new LinearConstraint(new double[hedgeSensitivityArray.length], Relationship.GEQ, 0));
        }

        // Create and run the solver
        SimplexSolver solver = new SimplexSolver();
        PointValuePair solution = solver.optimize(
                new MaxIter(100), // Maximum number of iterations
                objectiveFunction, // Objective function to minimize
                new LinearConstraintSet(constraints), // The constraints
                GoalType.MINIMIZE, // Type of optimization goal: minimize
                new NonNegativeConstraint(true) // The decision variables must be non-negative
        );

        // Output the solution
        double[] solutionPoint = solution.getPoint();
        System.out.println("Solution: ");
        for (double v : solutionPoint) {
            System.out.println(v);
        }
    }
}
