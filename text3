import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.RowFactory;
import org.apache.spark.sql.SparkSession;
import org.apache.spark.sql.types.DataTypes;
import org.apache.spark.sql.types.StructField;
import org.apache.spark.sql.types.StructType;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;

public class SbmCurvatureProcessor {

    public Dataset<Row> process(SparkSession sparkSession, Map<String, Dataset<Row>> dsMap) {
        
        // =====================================================================
        // 1. Input Retrieval
        // =====================================================================
        Dataset<Row> inputDs = dsMap.get("CURVATURE_WEIGHTED_SENSITIVITIES");
        Dataset<Row> corrDs = dsMap.get("CURVATURE_INTRA_BUCKET_RESULTS_CORR");

        if (inputDs == null || corrDs == null) throw new RuntimeException("Missing required datasets");

        // =====================================================================
        // 2. Prepare Correlation Lookup (Driver Local Map)
        // =====================================================================
        List<Row> corrRows = corrDs.select(
            "REGIME", "RISK_CLASS", "RISK_FACTOR_SCENARIO_FAMILY", "RISK_BUCKET",
            "IS_CVR_DOWN_POSITIVE_K", "IS_CVR_DOWN_POSITIVE_L", 
            "IS_CVR_UP_POSITIVE_K", "IS_CVR_UP_POSITIVE_L",     
            "RISK_FACTOR_NAME_1", "RISK_FACTOR_NAME_2",
            "CORRELATION_UP_MEDIUM", "CORRELATION_UP_LOW", "CORRELATION_UP_HIGH",
            "CORRELATION_DOWN_MEDIUM", "CORRELATION_DOWN_LOW", "CORRELATION_DOWN_HIGH"
        ).collectAsList();

        Map<String, double[]> correlationMap = new HashMap<>(corrRows.size());
        
        for (Row r : corrRows) {
            String baseKey = (r.isNullAt(0) ? "" : r.get(0).toString().trim()) + "|" + 
                             (r.isNullAt(1) ? "" : r.get(1).toString().trim()) + "|" + 
                             (r.isNullAt(2) ? "" : r.get(2).toString().trim()) + "|" + 
                             (r.isNullAt(3) ? "" : r.get(3).toString().trim());
            
            String signKey = (r.isNullAt(4) ? "N" : r.get(4).toString().trim()) + "|" + 
                             (r.isNullAt(5) ? "N" : r.get(5).toString().trim()) + "|" + 
                             (r.isNullAt(6) ? "N" : r.get(6).toString().trim()) + "|" + 
                             (r.isNullAt(7) ? "N" : r.get(7).toString().trim());

            String name1 = r.isNullAt(8) ? "" : r.get(8).toString().trim();
            String name2 = r.isNullAt(9) ? "" : r.get(9).toString().trim();
            
            // Key: Base | Signs | Name1 | Name2
            String fullKey = baseKey + "|" + signKey + "|" + name1 + "|" + name2;

            correlationMap.put(fullKey, new double[]{
                // Up [0-2]
                r.isNullAt(10) ? 0.0 : ((Number)r.get(10)).doubleValue(), // Med
                r.isNullAt(11) ? 0.0 : ((Number)r.get(11)).doubleValue(), // Low
                r.isNullAt(12) ? 0.0 : ((Number)r.get(12)).doubleValue(), // High
                // Down [3-5]
                r.isNullAt(13) ? 0.0 : ((Number)r.get(13)).doubleValue(), // Med
                r.isNullAt(14) ? 0.0 : ((Number)r.get(14)).doubleValue(), // Low
                r.isNullAt(15) ? 0.0 : ((Number)r.get(15)).doubleValue()  // High
            });
        }

        // =====================================================================
        // 3. Group Data
        // =====================================================================
        List<Row> allInputRows = inputDs.collectAsList();
        
        final int idxRegime = inputDs.schema().fieldIndex("REGIME");
        final int idxRiskClass = inputDs.schema().fieldIndex("RISK_CLASS");
        final int idxFamily = inputDs.schema().fieldIndex("RISK_FACTOR_SCENARIO_FAMILY");
        final int idxBucket = inputDs.schema().fieldIndex("RISK_BUCKET");
        final int idxName = inputDs.schema().fieldIndex("RISK_FACTOR_NAME");
        final int idxCvrUp = inputDs.schema().fieldIndex("CVR_UP");
        final int idxCvrDown = inputDs.schema().fieldIndex("CVR_DOWN");
        final int idxEntity = inputDs.schema().fieldIndex("REPORTING_ENTITY_COPER_ID");
        final int idxAggLvl = inputDs.schema().fieldIndex("AGGREGATION_LEVEL");
        final int idxAggVal = inputDs.schema().fieldIndex("AGGREGATION_LEVEL_VALUE");
        // Check if CVR column exists (from IMG_2391 aggregation requirement)
        // If not, we might assume it's CVR_UP + CVR_DOWN or similar, but usually it's passed through.
        // Assuming we calculate or pass through. Let's assume CVR_UP is the main proxy if CVR missing.

        Map<String, List<Row>> bucketGroups = new HashMap<>();

        for (Row r : allInputRows) {
            String k = (r.isNullAt(idxEntity) ? "" : r.get(idxEntity).toString().trim()) + "|" +
                       (r.isNullAt(idxAggLvl) ? "" : r.get(idxAggLvl).toString().trim()) + "|" +
                       (r.isNullAt(idxAggVal) ? "" : r.get(idxAggVal).toString().trim()) + "|" +
                       (r.isNullAt(idxRegime) ? "" : r.get(idxRegime).toString().trim()) + "|" +
                       (r.isNullAt(idxRiskClass) ? "" : r.get(idxRiskClass).toString().trim()) + "|" +
                       (r.isNullAt(idxFamily) ? "" : r.get(idxFamily).toString().trim()) + "|" +
                       (r.isNullAt(idxBucket) ? "" : r.get(idxBucket).toString().trim());
            bucketGroups.computeIfAbsent(k, x -> new ArrayList<>()).add(r);
        }

        // =====================================================================
        // 4. Parallel Calculation & Aggregation
        // =====================================================================
        List<Row> finalResults = Collections.synchronizedList(new ArrayList<>());

        bucketGroups.entrySet().parallelStream().forEach(entry -> {
            List<Row> rows = entry.getValue();
            int n = rows.size();
            if (n == 0) return;

            Row first = rows.get(0);
            String riskClass = first.isNullAt(idxRiskClass) ? "" : first.get(idxRiskClass).toString().trim();
            boolean isEquity = "EQUITY".equalsIgnoreCase(riskClass) || "CSR_NON_SEC".equalsIgnoreCase(riskClass);
            String baseKey = (first.isNullAt(idxRegime) ? "" : first.get(idxRegime).toString().trim()) + "|" +
                             riskClass + "|" +
                             (first.isNullAt(idxFamily) ? "" : first.get(idxFamily).toString().trim()) + "|" +
                             (first.isNullAt(idxBucket) ? "" : first.get(idxBucket).toString().trim());

            // Pre-process Arrays
            String[] names = new String[n];
            double[] cvrUps = new double[n];
            double[] cvrDowns = new double[n];
            String[] flagDownPos = new String[n];
            String[] flagUpPos = new String[n];

            for (int i = 0; i < n; i++) {
                Row r = rows.get(i);
                names[i] = r.isNullAt(idxName) ? "" : r.get(idxName).toString().trim();
                cvrUps[i] = r.isNullAt(idxCvrUp) ? 0.0 : r.getDouble(idxCvrUp);
                cvrDowns[i] = r.isNullAt(idxCvrDown) ? 0.0 : r.getDouble(idxCvrDown);
                
                flagDownPos[i] = cvrDowns[i] > 0 ? "Y" : "N";
                flagUpPos[i] = cvrUps[i] > 0 ? "Y" : "N";
            }

            // Loop i (Aggregation per Risk Factor)
            IntStream.range(0, n).forEach(i -> {
                // Accumulators for 3 Scenarios
                double sumUpMed = 0.0, sumUpLow = 0.0, sumUpHigh = 0.0;
                double sumDownMed = 0.0, sumDownLow = 0.0, sumDownHigh = 0.0;

                for (int j = 0; j < n; j++) {
                    // Optimization: Skip loop if self-join pair effectively contributes nothing
                    if (Math.abs(cvrUps[j]) < 1e-9 && Math.abs(cvrDowns[j]) < 1e-9) continue;

                    // Sign Logic (The "Zeroing" Effect)
                    double signIndUp = (cvrUps[i] < 0 && cvrUps[j] < 0) ? 0.0 : 1.0;
                    double signIndDown = (cvrDowns[i] < 0 && cvrDowns[j] < 0) ? 0.0 : 1.0;

                    String namePart1 = names[i];
                    String namePart2 = names[j];

                    if (isEquity) {
                        String diffIssuer = names[i].equals(names[j]) ? "N" : "Y";
                        namePart1 = diffIssuer;
                        namePart2 = diffIssuer;
                    }

                    String lookupKey = baseKey + "|" + 
                                       flagDownPos[i] + "|" + flagDownPos[j] + "|" + 
                                       flagUpPos[i] + "|" + flagUpPos[j] + "|" + 
                                       namePart1 + "|" + namePart2;

                    double[] corrs = correlationMap.get(lookupKey);

                    if (corrs != null) {
                        // Calculate Up Terms
                        double termUpBase = cvrUps[i] * cvrUps[j] * signIndUp;
                        if (Math.abs(termUpBase) > 1e-9) {
                            sumUpMed += termUpBase * corrs[0];
                            sumUpLow += termUpBase * corrs[1];
                            sumUpHigh += termUpBase * corrs[2];
                        }
                        // Calculate Down Terms
                        double termDownBase = cvrDowns[i] * cvrDowns[j] * signIndDown;
                        if (Math.abs(termDownBase) > 1e-9) {
                            sumDownMed += termDownBase * corrs[3];
                            sumDownLow += termDownBase * corrs[4];
                            sumDownHigh += termDownBase * corrs[5];
                        }
                    }
                }

                // =================================================================
                // OUTPUT GENERATION (Matches IMG_2391.jpg)
                // We explode the result into 3 rows (Medium, Low, High) per Factor
                // =================================================================
                
                // Common fields
                Object aggLvl = first.get(idxAggLvl);
                Object aggVal = first.get(idxAggVal);
                Object regime = first.get(idxRegime);
                Object entity = first.get(idxEntity);
                Object bucket = first.isNullAt(idxBucket) ? "" : first.get(idxBucket).toString().trim();
                Object rClass = first.get(idxRiskClass);
                Object family = first.get(idxFamily);
                
                // CVR MAX logic: Since we iterate per factor 'i', the MAX(CVR) for this group is just the value itself
                double valCvrUp = cvrUps[i];
                double valCvrDown = cvrDowns[i];
                // Assuming "CVR" = CVR_UP + CVR_DOWN or similar business rule. 
                // Using Max(Up, Down) as placeholder or just Sum depending on def. 
                // Based on standard risk logic, usually we output raw components. 
                // Let's output Up and Down as per screenshot columns.

                // Row 1: MEDIUM
                finalResults.add(RowFactory.create(
                    aggLvl, aggVal, regime, entity, bucket, rClass, family, 
                    "MEDIUM", // CORRELATION_SCENARIO
                    names[i], // RISK_FACTOR_NAME
                    sumUpMed, // TERM_OFF_DIAGONAL_UP
                    sumDownMed, // TERM_OFF_DIAGONAL_DOWN
                    valCvrUp, // CVR_UP (Matches MAX(CVR_UP_K))
                    valCvrDown // CVR_DOWN (Matches MAX(CVR_DOWN_K))
                ));

                // Row 2: LOW
                finalResults.add(RowFactory.create(
                    aggLvl, aggVal, regime, entity, bucket, rClass, family, 
                    "LOW", 
                    names[i], 
                    sumUpLow, 
                    sumDownLow, 
                    valCvrUp, 
                    valCvrDown 
                ));

                // Row 3: HIGH
                finalResults.add(RowFactory.create(
                    aggLvl, aggVal, regime, entity, bucket, rClass, family, 
                    "HIGH", 
                    names[i], 
                    sumUpHigh, 
                    sumDownHigh, 
                    valCvrUp, 
                    valCvrDown 
                ));
            });
        });

        // =====================================================================
        // 5. Output Schema
        // =====================================================================
        StructType outSchema = DataTypes.createStructType(new StructField[]{
            DataTypes.createStructField("AGGREGATION_LEVEL", DataTypes.StringType, true),
            DataTypes.createStructField("AGGREGATION_LEVEL_VALUE", DataTypes.StringType, true),
            DataTypes.createStructField("REGIME", DataTypes.StringType, true),
            DataTypes.createStructField("REPORTING_ENTITY_COPER_ID", DataTypes.IntegerType, true), 
            DataTypes.createStructField("RISK_BUCKET", DataTypes.StringType, true),
            DataTypes.createStructField("RISK_CLASS", DataTypes.StringType, true),
            DataTypes.createStructField("RISK_FACTOR_SCENARIO_FAMILY", DataTypes.StringType, true),
            DataTypes.createStructField("CORRELATION_SCENARIO", DataTypes.StringType, true), // New Column
            DataTypes.createStructField("RISK_FACTOR_NAME", DataTypes.StringType, true),
            
            // Aggregated Columns from IMG_2391
            DataTypes.createStructField("TERM_OFF_DIAGONAL_UP", DataTypes.DoubleType, false),
            DataTypes.createStructField("TERM_OFF_DIAGONAL_DOWN", DataTypes.DoubleType, false),
            DataTypes.createStructField("CVR_UP", DataTypes.DoubleType, false),
            DataTypes.createStructField("CVR_DOWN", DataTypes.DoubleType, false)
        });

        return sparkSession.createDataFrame(finalResults, outSchema);
    }
}
