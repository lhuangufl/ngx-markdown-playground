import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.RowFactory;
import org.apache.spark.sql.SparkSession;
import org.apache.spark.sql.types.DataTypes;
import org.apache.spark.sql.types.StructField;
import org.apache.spark.sql.types.StructType;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;

public class SbmCurvatureProcessor {

    public Dataset<Row> process(SparkSession sparkSession, Map<String, Dataset<Row>> dsMap) {
        
        // =====================================================================
        // 1. Input Retrieval
        // =====================================================================
        Dataset<Row> inputDs = dsMap.get("CURVATURE_WEIGHTED_SENSITIVITIES");
        Dataset<Row> corrDs = dsMap.get("CURVATURE_INTRA_BUCKET_RESULTS_CORR");

        if (inputDs == null || corrDs == null) throw new RuntimeException("Missing required datasets");

        // =====================================================================
        // 2. Prepare Correlation Lookup (Driver Local Map)
        // =====================================================================
        List<Row> corrRows = corrDs.select(
            "REGIME", "RISK_CLASS", "RISK_FACTOR_SCENARIO_FAMILY", "RISK_BUCKET",
            "IS_CVR_DOWN_POSITIVE_K", "IS_CVR_DOWN_POSITIVE_L", 
            "IS_CVR_UP_POSITIVE_K", "IS_CVR_UP_POSITIVE_L",     
            "RISK_FACTOR_NAME_1", "RISK_FACTOR_NAME_2",
            "CORRELATION_UP_MEDIUM", "CORRELATION_UP_LOW", "CORRELATION_UP_HIGH",
            "CORRELATION_DOWN_MEDIUM", "CORRELATION_DOWN_LOW", "CORRELATION_DOWN_HIGH"
        ).collectAsList();

        Map<String, double[]> correlationMap = new HashMap<>(corrRows.size());
        
        for (Row r : corrRows) {
            String baseKey = (r.isNullAt(0) ? "" : r.get(0).toString().trim()) + "|" + 
                             (r.isNullAt(1) ? "" : r.get(1).toString().trim()) + "|" + 
                             (r.isNullAt(2) ? "" : r.get(2).toString().trim()) + "|" + 
                             (r.isNullAt(3) ? "" : r.get(3).toString().trim());
            
            String signKey = (r.isNullAt(4) ? "N" : r.get(4).toString().trim()) + "|" + 
                             (r.isNullAt(5) ? "N" : r.get(5).toString().trim()) + "|" + 
                             (r.isNullAt(6) ? "N" : r.get(6).toString().trim()) + "|" + 
                             (r.isNullAt(7) ? "N" : r.get(7).toString().trim());

            String name1 = r.isNullAt(8) ? "" : r.get(8).toString().trim();
            String name2 = r.isNullAt(9) ? "" : r.get(9).toString().trim();
            
            String fullKey = baseKey + "|" + signKey + "|" + name1 + "|" + name2;

            correlationMap.put(fullKey, new double[]{
                // Up [0-2]
                r.isNullAt(10) ? 0.0 : ((Number)r.get(10)).doubleValue(), // Med
                r.isNullAt(11) ? 0.0 : ((Number)r.get(11)).doubleValue(), // Low
                r.isNullAt(12) ? 0.0 : ((Number)r.get(12)).doubleValue(), // High
                // Down [3-5]
                r.isNullAt(13) ? 0.0 : ((Number)r.get(13)).doubleValue(), // Med
                r.isNullAt(14) ? 0.0 : ((Number)r.get(14)).doubleValue(), // Low
                r.isNullAt(15) ? 0.0 : ((Number)r.get(15)).doubleValue()  // High
            });
        }

        // =====================================================================
        // 3. Group Data
        // =====================================================================
        List<Row> allInputRows = inputDs.collectAsList();
        
        // Capture Indices
        final int idxRegime = inputDs.schema().fieldIndex("REGIME");
        final int idxRiskClass = inputDs.schema().fieldIndex("RISK_CLASS");
        final int idxFamily = inputDs.schema().fieldIndex("RISK_FACTOR_SCENARIO_FAMILY");
        final int idxBucket = inputDs.schema().fieldIndex("RISK_BUCKET");
        final int idxExclBucket = inputDs.schema().fieldIndex("EXCLUDED_RISK_BUCKET"); // New Index
        final int idxName = inputDs.schema().fieldIndex("RISK_FACTOR_NAME");
        final int idxCvrUp = inputDs.schema().fieldIndex("CVR_UP");
        final int idxCvrDown = inputDs.schema().fieldIndex("CVR_DOWN");
        final int idxCvr = inputDs.schema().fieldIndex("CVR"); // New Index
        final int idxEntity = inputDs.schema().fieldIndex("REPORTING_ENTITY_COPER_ID");
        final int idxAggLvl = inputDs.schema().fieldIndex("AGGREGATION_LEVEL");
        final int idxAggVal = inputDs.schema().fieldIndex("AGGREGATION_LEVEL_VALUE");

        Map<String, List<Row>> bucketGroups = new HashMap<>();

        for (Row r : allInputRows) {
            // [Group Key] Now includes EXCLUDED_RISK_BUCKET to ensure correct grouping
            String k = (r.isNullAt(idxEntity) ? "" : r.get(idxEntity).toString().trim()) + "|" +
                       (r.isNullAt(idxAggLvl) ? "" : r.get(idxAggLvl).toString().trim()) + "|" +
                       (r.isNullAt(idxAggVal) ? "" : r.get(idxAggVal).toString().trim()) + "|" +
                       (r.isNullAt(idxRegime) ? "" : r.get(idxRegime).toString().trim()) + "|" +
                       (r.isNullAt(idxRiskClass) ? "" : r.get(idxRiskClass).toString().trim()) + "|" +
                       (r.isNullAt(idxFamily) ? "" : r.get(idxFamily).toString().trim()) + "|" +
                       (r.isNullAt(idxBucket) ? "" : r.get(idxBucket).toString().trim()) + "|" +
                       (r.isNullAt(idxExclBucket) ? "" : r.get(idxExclBucket).toString().trim()); // Added
            
            bucketGroups.computeIfAbsent(k, x -> new ArrayList<>()).add(r);
        }

        // =====================================================================
        // 4. Parallel Calculation & Aggregation
        // =====================================================================
        List<Row> finalResults = Collections.synchronizedList(new ArrayList<>());

        bucketGroups.entrySet().parallelStream().forEach(entry -> {
            List<Row> rows = entry.getValue();
            int n = rows.size();
            if (n == 0) return;

            Row first = rows.get(0);
            String riskClass = first.isNullAt(idxRiskClass) ? "" : first.get(idxRiskClass).toString().trim();
            boolean isEquity = "EQUITY".equalsIgnoreCase(riskClass) || "CSR_NON_SEC".equalsIgnoreCase(riskClass);
            String baseKey = (first.isNullAt(idxRegime) ? "" : first.get(idxRegime).toString().trim()) + "|" +
                             riskClass + "|" +
                             (first.isNullAt(idxFamily) ? "" : first.get(idxFamily).toString().trim()) + "|" +
                             (first.isNullAt(idxBucket) ? "" : first.get(idxBucket).toString().trim());

            // Pre-process Arrays
            String[] names = new String[n];
            double[] cvrUps = new double[n];
            double[] cvrDowns = new double[n];
            double[] cvrs = new double[n]; // Store CVR values
            String[] flagDownPos = new String[n];
            String[] flagUpPos = new String[n];

            for (int i = 0; i < n; i++) {
                Row r = rows.get(i);
                names[i] = r.isNullAt(idxName) ? "" : r.get(idxName).toString().trim();
                cvrUps[i] = r.isNullAt(idxCvrUp) ? 0.0 : r.getDouble(idxCvrUp);
                cvrDowns[i] = r.isNullAt(idxCvrDown) ? 0.0 : r.getDouble(idxCvrDown);
                cvrs[i] = r.isNullAt(idxCvr) ? 0.0 : r.getDouble(idxCvr); // Capture CVR
                
                flagDownPos[i] = cvrDowns[i] > 0 ? "Y" : "N";
                flagUpPos[i] = cvrUps[i] > 0 ? "Y" : "N";
            }

            // Loop i (Aggregation per Risk Factor)
            IntStream.range(0, n).forEach(i -> {
                double sumUpMed = 0.0, sumUpLow = 0.0, sumUpHigh = 0.0;
                double sumDownMed = 0.0, sumDownLow = 0.0, sumDownHigh = 0.0;

                for (int j = 0; j < n; j++) {
                    if (Math.abs(cvrUps[j]) < 1e-9 && Math.abs(cvrDowns[j]) < 1e-9) continue;

                    // Curvature Zeroing Logic
                    double signIndUp = (cvrUps[i] < 0 && cvrUps[j] < 0) ? 0.0 : 1.0;
                    double signIndDown = (cvrDowns[i] < 0 && cvrDowns[j] < 0) ? 0.0 : 1.0;

                    String namePart1 = names[i];
                    String namePart2 = names[j];

                    if (isEquity) {
                        String diffIssuer = names[i].equals(names[j]) ? "N" : "Y";
                        namePart1 = diffIssuer;
                        namePart2 = diffIssuer;
                    }

                    String lookupKey = baseKey + "|" + 
                                       flagDownPos[i] + "|" + flagDownPos[j] + "|" + 
                                       flagUpPos[i] + "|" + flagUpPos[j] + "|" + 
                                       namePart1 + "|" + namePart2;

                    double[] corrs = correlationMap.get(lookupKey);

                    if (corrs != null) {
                        double termUpBase = cvrUps[i] * cvrUps[j] * signIndUp;
                        if (Math.abs(termUpBase) > 1e-9) {
                            sumUpMed += termUpBase * corrs[0];
                            sumUpLow += termUpBase * corrs[1];
                            sumUpHigh += termUpBase * corrs[2];
                        }
                        double termDownBase = cvrDowns[i] * cvrDowns[j] * signIndDown;
                        if (Math.abs(termDownBase) > 1e-9) {
                            sumDownMed += termDownBase * corrs[3];
                            sumDownLow += termDownBase * corrs[4];
                            sumDownHigh += termDownBase * corrs[5];
                        }
                    }
                }

                // =================================================================
                // OUTPUT GENERATION
                // =================================================================
                Object aggLvl = first.get(idxAggLvl);
                Object aggVal = first.get(idxAggVal);
                Object regime = first.get(idxRegime);
                Object entity = first.get(idxEntity);
                Object bucket = first.isNullAt(idxBucket) ? "" : first.get(idxBucket).toString().trim();
                // Get Excluded Bucket from the row
                Object exclBucket = first.isNullAt(idxExclBucket) ? "" : first.get(idxExclBucket).toString().trim();
                Object rClass = first.get(idxRiskClass);
                Object family = first.get(idxFamily);
                
                // Retrieve the CVR for this specific risk factor 'i'
                double valCvr = cvrs[i]; 
                double valCvrUp = cvrUps[i];
                double valCvrDown = cvrDowns[i];

                // Explode to 3 Scenarios
                finalResults.add(RowFactory.create(
                    aggLvl, aggVal, regime, entity, bucket, exclBucket, rClass, family, 
                    "MEDIUM", names[i], sumUpMed, sumDownMed, valCvr, valCvrUp, valCvrDown
                ));

                finalResults.add(RowFactory.create(
                    aggLvl, aggVal, regime, entity, bucket, exclBucket, rClass, family, 
                    "LOW", names[i], sumUpLow, sumDownLow, valCvr, valCvrUp, valCvrDown
                ));

                finalResults.add(RowFactory.create(
                    aggLvl, aggVal, regime, entity, bucket, exclBucket, rClass, family, 
                    "HIGH", names[i], sumUpHigh, sumDownHigh, valCvr, valCvrUp, valCvrDown
                ));
            });
        });

        // =====================================================================
        // 5. Output Schema
        // =====================================================================
        StructType outSchema = DataTypes.createStructType(new StructField[]{
            DataTypes.createStructField("AGGREGATION_LEVEL", DataTypes.StringType, true),
            DataTypes.createStructField("AGGREGATION_LEVEL_VALUE", DataTypes.StringType, true),
            DataTypes.createStructField("REGIME", DataTypes.StringType, true),
            DataTypes.createStructField("REPORTING_ENTITY_COPER_ID", DataTypes.IntegerType, true), 
            DataTypes.createStructField("RISK_BUCKET", DataTypes.StringType, true),
            DataTypes.createStructField("EXCLUDED_RISK_BUCKET", DataTypes.StringType, true), // Added
            DataTypes.createStructField("RISK_CLASS", DataTypes.StringType, true),
            DataTypes.createStructField("RISK_FACTOR_SCENARIO_FAMILY", DataTypes.StringType, true),
            DataTypes.createStructField("CORRELATION_SCENARIO", DataTypes.StringType, true),
            DataTypes.createStructField("RISK_FACTOR_NAME", DataTypes.StringType, true),
            DataTypes.createStructField("TERM_OFF_DIAGONAL_UP", DataTypes.DoubleType, false),
            DataTypes.createStructField("TERM_OFF_DIAGONAL_DOWN", DataTypes.DoubleType, false),
            DataTypes.createStructField("CVR", DataTypes.DoubleType, false), // Added
            DataTypes.createStructField("CVR_UP", DataTypes.DoubleType, false),
            DataTypes.createStructField("CVR_DOWN", DataTypes.DoubleType, false)
        });

        return sparkSession.createDataFrame(finalResults, outSchema);
    }
}
